From: Jason Dillaman <dillaman@redhat.com>
Date: Mon, 27 Jun 2016 09:05:33 -0400
Subject: rbd-mirror: clean up ImageReplayer before stopping state machine

Fixes: http://tracker.ceph.com/issues/16489
Signed-off-by: Jason Dillaman <dillaman@redhat.com>

Resolves: rhbz#1350351

Conflicts:
	src/tools/rbd_mirror/ImageReplayer.cc: trivial resolution
---
 src/tools/rbd_mirror/ImageReplayer.cc | 20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/tools/rbd_mirror/ImageReplayer.cc b/src/tools/rbd_mirror/ImageReplayer.cc
index 544bbaf..0172373 100644
--- a/src/tools/rbd_mirror/ImageReplayer.cc
+++ b/src/tools/rbd_mirror/ImageReplayer.cc
@@ -1217,7 +1217,6 @@ template <typename I>
 void ImageReplayer<I>::handle_shut_down(int r, Context *on_start) {
   reschedule_update_status_task(-1);
 
-  Context *on_stop = nullptr;
   {
     Mutex::Locker locker(m_lock);
 
@@ -1233,21 +1232,26 @@ void ImageReplayer<I>::handle_shut_down(int r, Context *on_start) {
       return;
     }
 
-    std::swap(on_stop, m_on_stop_finish);
-    m_stop_requested = false;
-    assert(m_state == STATE_STOPPING);
-    m_state = STATE_STOPPED;
-    m_state_desc.clear();
-    m_last_r = 0;
   }
-  dout(20) << "stop complete" << dendl;
 
+  dout(20) << "stop complete" << dendl;
   m_local_ioctx.close();
   m_remote_ioctx.close();
 
   delete m_replay_status_formatter;
   m_replay_status_formatter = nullptr;
 
+  Context *on_stop = nullptr;
+  {
+    Mutex::Locker locker(m_lock);
+    std::swap(on_stop, m_on_stop_finish);
+    m_stop_requested = false;
+    assert(m_state == STATE_STOPPING);
+    m_state = STATE_STOPPED;
+    m_state_desc.clear();
+    m_last_r = 0;
+  }
+
   if (on_start != nullptr) {
     dout(20) << "on start finish complete, r=" << r << dendl;
     on_start->complete(r);
