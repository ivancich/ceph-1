From: Josh Durgin <jdurgin@redhat.com>
Date: Thu, 13 Jul 2017 14:44:21 -0400
Subject: PGLog,
 PrimaryLogPG: rebuild the missing set when the OSDMap flag is set

The recovery_deletes flag will only be set once, by the 'ceph osd
require-osd-release luminous' command.

This matches how we rebuild the missing set when reading it off disk in
read_log_and_missing().

Signed-off-by: Josh Durgin <jdurgin@redhat.com>
(cherry picked from commit b09249dee27f9586c4809a22f909725921eb82db)

Resolves: rhbz#1452780
---
 src/osd/PGLog.cc        | 54 +++++++++++++++++++++++++++++++++++++++++++++++++
 src/osd/PGLog.h         |  4 ++++
 src/osd/ReplicatedPG.cc |  7 +++++++
 3 files changed, 65 insertions(+)

diff --git a/src/osd/PGLog.cc b/src/osd/PGLog.cc
index 475eeb2..6dac09e 100644
--- a/src/osd/PGLog.cc
+++ b/src/osd/PGLog.cc
@@ -1082,3 +1082,57 @@ void PGLog::read_log(ObjectStore *store, coll_t pg_coll,
   ldpp_dout(dpp, 10) << "read_log done" << dendl;
 }
 
+void PGLog::rebuild_missing_set_with_deletes(ObjectStore *store,
+					     coll_t pg_coll,
+					     const pg_info_t &info)
+{
+  // save entries not generated from the current log (e.g. added due
+  // to repair, EIO handling, or divergent_priors).
+  map<hobject_t, pg_missing_t::item, hobject_t::ComparatorWithDefault> extra_missing;
+  for (const auto& p : missing.missing) {
+    if (!log.logged_object(p.first)) {
+      dout(20) << __func__ << " extra missing entry: " << p.first
+	       << " " << p.second << dendl;
+      extra_missing[p.first] = p.second;
+    }
+  }
+  missing.clear();
+  missing.may_include_deletes = true;
+
+  // go through the log and add items that are not present or older
+  // versions on disk, just as if we were reading the log + metadata
+  // off disk originally
+  set<hobject_t, hobject_t::ComparatorWithDefault> did;
+  for (list<pg_log_entry_t>::reverse_iterator i = log.log.rbegin();
+       i != log.log.rend();
+       ++i) {
+    if (i->version <= info.last_complete)
+      break;
+    if (cmp(i->soid, info.last_backfill, info.last_backfill_bitwise) > 0 ||
+	did.find(i->soid) != did.end())
+      continue;
+    did.insert(i->soid);
+
+    bufferlist bv;
+    int r = store->getattr(
+	pg_coll,
+	ghobject_t(i->soid, ghobject_t::NO_GEN, info.pgid.shard),
+	OI_ATTR,
+	bv);
+    dout(20) << __func__ << " check for log entry: " << *i << " = " << r << dendl;
+
+    if (r >= 0) {
+      object_info_t oi(bv);
+      dout(20) << __func__ << " store version = " << oi.version << dendl;
+      if (oi.version < i->version) {
+	missing.add(i->soid, i->version, oi.version, i->is_delete());
+      }
+    } else {
+      missing.add(i->soid, i->version, eversion_t(), i->is_delete());
+    }
+  }
+
+  for (const auto& p : extra_missing) {
+    missing.add(p.first, p.second.need, p.second.have, p.second.is_delete());
+  }
+}
diff --git a/src/osd/PGLog.h b/src/osd/PGLog.h
index c214bc7..33a1689 100644
--- a/src/osd/PGLog.h
+++ b/src/osd/PGLog.h
@@ -684,6 +684,10 @@ public:
   void proc_replica_log(ObjectStore::Transaction& t, pg_info_t &oinfo, const pg_log_t &olog,
 			pg_missing_t& omissing, pg_shard_t from) const;
 
+  void rebuild_missing_set_with_deletes(ObjectStore *store,
+					coll_t pg_coll,
+					const pg_info_t &info);
+
 protected:
   static void split_by_object(
     list<pg_log_entry_t> &entries,
diff --git a/src/osd/ReplicatedPG.cc b/src/osd/ReplicatedPG.cc
index ee067bb..301fd1f 100644
--- a/src/osd/ReplicatedPG.cc
+++ b/src/osd/ReplicatedPG.cc
@@ -10169,6 +10169,13 @@ void ReplicatedPG::_on_new_interval()
     object_contexts.reset_comparator(
       hobject_t::ComparatorWithDefault(get_sort_bitwise()));
   }
+
+  dout(20) << __func__ << " checking missing set deletes flag. missing = " << pg_log.get_missing() << dendl;
+  if (!pg_log.get_missing().may_include_deletes &&
+      get_osdmap()->test_flag(CEPH_OSDMAP_RECOVERY_DELETES)) {
+    pg_log.rebuild_missing_set_with_deletes(osd->store, coll, info);
+  }
+  assert(pg_log.get_missing().may_include_deletes == get_osdmap()->test_flag(CEPH_OSDMAP_RECOVERY_DELETES));
 }
 
 void ReplicatedPG::on_change(ObjectStore::Transaction *t)
