From: root <root@ceph-node1.homeoffice.wal-mart.com>
Date: Mon, 23 May 2016 15:34:58 +0530
Subject: rgw: default quota fixes

- Let the default quota settings take effect during user creation
- Do not bother to check against conf values during quota handling

Signed-off-by: Pavan Rallabhandi <PRallabhandi@walmartlabs.com>
Signed-off-by: Daniel Gryniewicz <dang@redhat.com>
(cherry picked from commit caddab9b5d111aa568a1ae531061d2a4765eb948)
(cherry picked from commit 63a160769115d08ab47c6ab0df5f3a872bf11097)

Resolves: rhbz#1362284

RHCS downstream: had to drop the changes to doc .rst files (e3ab347),
since those files are not present in the v10.2.2 release tarball.
---
 src/rgw/rgw_quota.cc     | 56 +++++++++++-------------------------------------
 src/rgw/rgw_rest_user.cc | 31 +++++++++++++++++++++++++++
 src/rgw/rgw_user.cc      | 24 +++++++++++++++++++--
 3 files changed, 66 insertions(+), 45 deletions(-)

diff --git a/src/rgw/rgw_quota.cc b/src/rgw/rgw_quota.cc
index 0ea17d5..fdea870 100644
--- a/src/rgw/rgw_quota.cc
+++ b/src/rgw/rgw_quota.cc
@@ -694,73 +694,43 @@ class RGWQuotaHandlerImpl : public RGWQuotaHandler {
     return 0;
   }
 public:
-  RGWQuotaHandlerImpl(RGWRados *_store, bool quota_threads) : store(_store), bucket_stats_cache(_store), user_stats_cache(_store, quota_threads) {
-    if (store->ctx()->_conf->rgw_bucket_default_quota_max_objects >= 0) {
-      def_bucket_quota.max_objects = store->ctx()->_conf->rgw_bucket_default_quota_max_objects;
-      def_bucket_quota.enabled = true;
-    }
-    if (store->ctx()->_conf->rgw_bucket_default_quota_max_size >= 0) {
-      def_bucket_quota.max_size_kb = store->ctx()->_conf->rgw_bucket_default_quota_max_size;
-      def_bucket_quota.enabled = true;
-    }
-    if (store->ctx()->_conf->rgw_user_default_quota_max_objects >= 0) {
-      def_user_quota.max_objects = store->ctx()->_conf->rgw_user_default_quota_max_objects;
-      def_user_quota.enabled = true;
-    }
-    if (store->ctx()->_conf->rgw_user_default_quota_max_size >= 0) {
-      def_user_quota.max_size_kb = store->ctx()->_conf->rgw_user_default_quota_max_size;
-      def_user_quota.enabled = true;
-    }
-  }
+  RGWQuotaHandlerImpl(RGWRados *_store, bool quota_threads) : store(_store),
+                                    bucket_stats_cache(_store),
+                                    user_stats_cache(_store, quota_threads) {}
+
   virtual int check_quota(const rgw_user& user, rgw_bucket& bucket,
                           RGWQuotaInfo& user_quota, RGWQuotaInfo& bucket_quota,
 			  uint64_t num_objs, uint64_t size) {
 
-    if (!bucket_quota.enabled && !user_quota.enabled && !def_bucket_quota.enabled && !def_user_quota.enabled)
+    if (!bucket_quota.enabled && !user_quota.enabled)
       return 0;
 
     uint64_t size_kb = rgw_rounded_objsize_kb(size);
 
-    RGWStorageStats bucket_stats;
-
     /*
      * we need to fetch bucket stats if the user quota is enabled, because the whole system relies
      * on us periodically updating the user's bucket stats in the user's header, this happens in
      * get_stats() if we actually fetch that info and not rely on cached data
      */
 
-    int ret = bucket_stats_cache.get_stats(user, bucket, bucket_stats, bucket_quota);
-    if (ret < 0)
-      return ret;
-
     if (bucket_quota.enabled) {
-      ret = check_quota("bucket", bucket_quota, bucket_stats, num_objs, size_kb);
+      RGWStorageStats bucket_stats;
+      int ret = bucket_stats_cache.get_stats(user, bucket, bucket_stats, bucket_quota);
       if (ret < 0)
         return ret;
-    }
 
-    if (def_bucket_quota.enabled) {
-      ret = check_quota("def_bucket", def_bucket_quota, bucket_stats, num_objs, size_kb);
-      if (ret < 0)
-        return ret;
+      ret = check_quota("bucket", bucket_quota, bucket_stats, num_objs, size_kb);
     }
 
-    if (user_quota.enabled || def_user_quota.enabled) {
+    if (user_quota.enabled) {
       RGWStorageStats user_stats;
-
-      ret = user_stats_cache.get_stats(user, bucket, user_stats, user_quota);
+      int ret = user_stats_cache.get_stats(user, bucket, user_stats, user_quota);
       if (ret < 0)
         return ret;
 
-      if (user_quota.enabled) {
-	ret = check_quota("user", user_quota, user_stats, num_objs, size_kb);
-	if (ret < 0)
-	  return ret;
-      } else if (def_user_quota.enabled) {
-        ret = check_quota("def_user", def_user_quota, user_stats, num_objs, size_kb);
-        if (ret < 0)
-          return ret;
-      }
+      ret = check_quota("user", user_quota, user_stats, num_objs, size_kb);
+      if (ret < 0)
+	return ret;
     }
 
     return 0;
diff --git a/src/rgw/rgw_rest_user.cc b/src/rgw/rgw_rest_user.cc
index 587e6d0..ef0d7ad 100644
--- a/src/rgw/rgw_rest_user.cc
+++ b/src/rgw/rgw_rest_user.cc
@@ -143,6 +143,37 @@ void RGWOp_User_Create::execute()
   if (gen_key)
     op_state.set_generate_key();
 
+  RGWQuotaInfo bucket_quota;
+  RGWQuotaInfo user_quota;
+
+  if (s->cct->_conf->rgw_bucket_default_quota_max_objects >= 0) {
+    bucket_quota.max_objects = s->cct->_conf->rgw_bucket_default_quota_max_objects;
+    bucket_quota.enabled = true;
+  }
+
+  if (s->cct->_conf->rgw_bucket_default_quota_max_size >= 0) {
+    bucket_quota.max_size_kb = s->cct->_conf->rgw_bucket_default_quota_max_size;
+    bucket_quota.enabled = true;
+  }
+
+  if (s->cct->_conf->rgw_user_default_quota_max_objects >= 0) {
+    user_quota.max_objects = s->cct->_conf->rgw_user_default_quota_max_objects;
+    user_quota.enabled = true;
+  }
+
+  if (s->cct->_conf->rgw_user_default_quota_max_size >= 0) {
+    user_quota.max_size_kb = s->cct->_conf->rgw_user_default_quota_max_size;
+    user_quota.enabled = true;
+  }
+
+  if (bucket_quota.enabled) {
+    op_state.set_bucket_quota(bucket_quota);
+  }
+
+  if (user_quota.enabled) {
+    op_state.set_user_quota(user_quota);
+  }
+
   http_ret = RGWUserAdminOp_User::create(store, op_state, flusher);
 }
 
diff --git a/src/rgw/rgw_user.cc b/src/rgw/rgw_user.cc
index 53f4a75..a9621d1 100644
--- a/src/rgw/rgw_user.cc
+++ b/src/rgw/rgw_user.cc
@@ -1929,8 +1929,18 @@ int RGWUser::execute_add(RGWUserAdminOpState& op_state, std::string *err_msg)
   if (op_state.op_mask_specified)
     user_info.op_mask = op_state.get_op_mask();
 
-  if (op_state.has_bucket_quota())
+  if (op_state.has_bucket_quota()) {
     user_info.bucket_quota = op_state.get_bucket_quota();
+  } else {
+    if (cct->_conf->rgw_bucket_default_quota_max_objects >= 0) {
+      user_info.bucket_quota.max_objects = cct->_conf->rgw_bucket_default_quota_max_objects;
+      user_info.bucket_quota.enabled = true;
+    }
+    if (cct->_conf->rgw_bucket_default_quota_max_size >= 0) {
+      user_info.bucket_quota.max_size_kb = cct->_conf->rgw_bucket_default_quota_max_size;
+      user_info.bucket_quota.enabled = true;
+    }
+  }
 
   if (op_state.temp_url_key_specified) {
     map<int, string>::iterator iter;
@@ -1940,8 +1950,18 @@ int RGWUser::execute_add(RGWUserAdminOpState& op_state, std::string *err_msg)
     }
   }
 
-  if (op_state.has_user_quota())
+  if (op_state.has_user_quota()) {
     user_info.user_quota = op_state.get_user_quota();
+  } else {
+    if (cct->_conf->rgw_user_default_quota_max_objects >= 0) {
+      user_info.user_quota.max_objects = cct->_conf->rgw_user_default_quota_max_objects;
+      user_info.user_quota.enabled = true;
+    }
+    if (cct->_conf->rgw_user_default_quota_max_size >= 0) {
+      user_info.user_quota.max_size_kb = cct->_conf->rgw_user_default_quota_max_size;
+      user_info.user_quota.enabled = true;
+    }
+  }
 
   // update the request
   op_state.set_user_info(user_info);
