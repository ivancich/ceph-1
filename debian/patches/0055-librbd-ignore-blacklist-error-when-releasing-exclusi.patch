From: Jason Dillaman <dillaman@redhat.com>
Date: Wed, 4 Jan 2017 12:12:27 -0500
Subject: librbd: ignore blacklist error when releasing exclusive lock

This ensures the journal and object map are properly closed so that the
image can be properly closed w/o failing any assertions.

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit 418dcf29cb8c450049047e09a4dad2941af87018)
(cherry picked from commit 1e08a7f6b64c0fc29ba43503cb17a21e2d113076)

Resolves: rhbz#1408226
---
 src/librbd/exclusive_lock/ReleaseRequest.cc        |  6 +++-
 .../exclusive_lock/test_mock_ReleaseRequest.cc     | 37 ++++++++++++++++++++++
 2 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/src/librbd/exclusive_lock/ReleaseRequest.cc b/src/librbd/exclusive_lock/ReleaseRequest.cc
index 52343f8..dc49653 100644
--- a/src/librbd/exclusive_lock/ReleaseRequest.cc
+++ b/src/librbd/exclusive_lock/ReleaseRequest.cc
@@ -127,7 +127,11 @@ Context *ReleaseRequest<I>::handle_block_writes(int *ret_val) {
   CephContext *cct = m_image_ctx.cct;
   ldout(cct, 10) << __func__ << ": r=" << *ret_val << dendl;
 
-  if (*ret_val < 0) {
+  if (*ret_val == -EBLACKLISTED) {
+    // allow clean shut down if blacklisted
+    lderr(cct) << "failed to block writes: " << cpp_strerror(*ret_val) << dendl;
+    *ret_val = 0;
+  } else if (*ret_val < 0) {
     m_image_ctx.aio_work_queue->unblock_writes();
     return m_on_finish;
   }
diff --git a/src/test/librbd/exclusive_lock/test_mock_ReleaseRequest.cc b/src/test/librbd/exclusive_lock/test_mock_ReleaseRequest.cc
index e2fb842..8010998 100644
--- a/src/test/librbd/exclusive_lock/test_mock_ReleaseRequest.cc
+++ b/src/test/librbd/exclusive_lock/test_mock_ReleaseRequest.cc
@@ -206,6 +206,43 @@ TEST_F(TestMockExclusiveLockReleaseRequest, SuccessObjectMapDisabled) {
   ASSERT_EQ(0, ctx.wait());
 }
 
+TEST_F(TestMockExclusiveLockReleaseRequest, Blacklisted) {
+  REQUIRE_FEATURE(RBD_FEATURE_EXCLUSIVE_LOCK);
+
+  librbd::ImageCtx *ictx;
+  ASSERT_EQ(0, open_image(m_image_name, &ictx));
+
+  MockImageCtx mock_image_ctx(*ictx);
+  expect_op_work_queue(mock_image_ctx);
+
+  InSequence seq;
+  expect_prepare_lock(mock_image_ctx);
+  expect_cancel_op_requests(mock_image_ctx, 0);
+  expect_block_writes(mock_image_ctx, -EBLACKLISTED);
+  expect_flush_notifies(mock_image_ctx);
+
+  MockJournal *mock_journal = new MockJournal();
+  mock_image_ctx.journal = mock_journal;
+  expect_close_journal(mock_image_ctx, *mock_journal, -EBLACKLISTED);
+
+  MockObjectMap *mock_object_map = new MockObjectMap();
+  mock_image_ctx.object_map = mock_object_map;
+  expect_close_object_map(mock_image_ctx, *mock_object_map);
+
+  MockContext mock_releasing_ctx;
+  expect_complete_context(mock_releasing_ctx, 0);
+  expect_unlock(mock_image_ctx, -EBLACKLISTED);
+  expect_handle_prepare_lock_complete(mock_image_ctx);
+
+  C_SaferCond ctx;
+  MockReleaseRequest *req = MockReleaseRequest::create(mock_image_ctx,
+                                                       TEST_COOKIE,
+                                                       &mock_releasing_ctx,
+                                                       &ctx, false);
+  req->send();
+  ASSERT_EQ(0, ctx.wait());
+}
+
 TEST_F(TestMockExclusiveLockReleaseRequest, BlockWritesError) {
   REQUIRE_FEATURE(RBD_FEATURE_EXCLUSIVE_LOCK);
 
