From: Jason Dillaman <dillaman@redhat.com>
Date: Tue, 17 May 2016 23:31:02 -0400
Subject: rbd-mirror: track bootstrap state within image status

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit e5dd97b4bf4a993911febf34dce90470a2a91d59)
(cherry picked from commit f789d83cbb9dbb1a6daa15585e2be2980ea19616)
---
 src/tools/rbd_mirror/ImageReplayer.cc | 17 +++++++++++++----
 src/tools/rbd_mirror/ImageReplayer.h  |  3 +++
 2 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/tools/rbd_mirror/ImageReplayer.cc b/src/tools/rbd_mirror/ImageReplayer.cc
index 4ba7e98..443c180 100644
--- a/src/tools/rbd_mirror/ImageReplayer.cc
+++ b/src/tools/rbd_mirror/ImageReplayer.cc
@@ -372,8 +372,6 @@ void ImageReplayer<I>::bootstrap() {
   dout(20) << "bootstrap params: "
 	   << "local_image_name=" << m_local_image_name << dendl;
 
-  update_mirror_image_status();
-
   // TODO: add a new bootstrap state and support canceling
   Context *ctx = create_context_callback<
     ImageReplayer, &ImageReplayer<I>::handle_bootstrap>(this);
@@ -384,13 +382,25 @@ void ImageReplayer<I>::bootstrap() {
     m_threads->work_queue, m_threads->timer, &m_threads->timer_lock,
     m_local_mirror_uuid, m_remote_mirror_uuid, m_remote_journaler,
     &m_client_meta, ctx, &m_progress_cxt);
+
+  {
+    Mutex::Locker locker(m_lock);
+    m_bootstrap_request = request;
+  }
+
   request->send();
+  update_mirror_image_status();
 }
 
 template <typename I>
 void ImageReplayer<I>::handle_bootstrap(int r) {
   dout(20) << "r=" << r << dendl;
 
+  {
+    Mutex::Locker locker(m_lock);
+    m_bootstrap_request = nullptr;
+  }
+
   if (r == -EREMOTEIO) {
     dout(5) << "remote image is non-primary or local image is primary" << dendl;
     on_start_fail_start(0, "remote image is non-primary or local image is primary");
@@ -1068,8 +1078,7 @@ void ImageReplayer<I>::update_mirror_image_status(bool final,
 
     switch (m_state) {
     case STATE_STARTING:
-      // TODO: a better way to detect syncing state.
-      if (!m_asok_hook) {
+      if (m_bootstrap_request != nullptr) {
 	status.state = cls::rbd::MIRROR_IMAGE_STATUS_STATE_SYNCING;
 	status.description = m_state_desc.empty() ? "syncing" : m_state_desc;
       } else {
diff --git a/src/tools/rbd_mirror/ImageReplayer.h b/src/tools/rbd_mirror/ImageReplayer.h
index af8133d..42ad9f9 100644
--- a/src/tools/rbd_mirror/ImageReplayer.h
+++ b/src/tools/rbd_mirror/ImageReplayer.h
@@ -40,6 +40,7 @@ namespace mirror {
 
 struct Threads;
 
+namespace image_replayer { template <typename> class BootstrapRequest; }
 namespace image_replayer { template <typename> class ReplayStatusFormatter; }
 
 /**
@@ -231,6 +232,8 @@ private:
 
   AdminSocketHook *m_asok_hook = nullptr;
 
+  image_replayer::BootstrapRequest<ImageCtxT> *m_bootstrap_request = nullptr;
+
   librbd::journal::MirrorPeerClientMeta m_client_meta;
 
   ReplayEntry m_replay_entry;
