From: Jason Dillaman <dillaman@redhat.com>
Date: Tue, 16 Aug 2016 13:11:19 -0400
Subject: librbd: store exclusive lock cookie instead of recalculating

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit aa53f74ad261f453e971bf3cef0b96bba4932b7b)
(cherry picked from commit 2af0a71c178e94879cfbb1eb12117f7138f2a6bc)

Resolves: rhbz#1379837
---
 src/librbd/ExclusiveLock.cc                        | 11 ++++++----
 src/librbd/ExclusiveLock.h                         |  1 +
 .../exclusive_lock/test_mock_ReacquireRequest.cc   | 25 ++++++----------------
 3 files changed, 15 insertions(+), 22 deletions(-)

diff --git a/src/librbd/ExclusiveLock.cc b/src/librbd/ExclusiveLock.cc
index 1d0248c..99d7b1d 100644
--- a/src/librbd/ExclusiveLock.cc
+++ b/src/librbd/ExclusiveLock.cc
@@ -224,7 +224,7 @@ template <typename I>
 void ExclusiveLock<I>::assert_header_locked(librados::ObjectWriteOperation *op) {
   Mutex::Locker locker(m_lock);
   rados::cls::lock::assert_locked(op, RBD_LOCK_NAME, LOCK_EXCLUSIVE,
-                                  encode_lock_cookie(), WATCHER_LOCK_TAG);
+                                  m_cookie, WATCHER_LOCK_TAG);
 }
 
 template <typename I>
@@ -384,9 +384,11 @@ void ExclusiveLock<I>::send_acquire_lock() {
     return;
   }
 
+  m_cookie = encode_lock_cookie();
+
   using el = ExclusiveLock<I>;
   AcquireRequest<I>* req = AcquireRequest<I>::create(
-    m_image_ctx, encode_lock_cookie(),
+    m_image_ctx, m_cookie,
     util::create_context_callback<el, &el::handle_acquiring_lock>(this),
     util::create_context_callback<el, &el::handle_acquire_lock>(this));
 
@@ -468,7 +470,7 @@ void ExclusiveLock<I>::send_release_lock() {
 
   using el = ExclusiveLock<I>;
   ReleaseRequest<I>* req = ReleaseRequest<I>::create(
-    m_image_ctx, encode_lock_cookie(),
+    m_image_ctx, m_cookie,
     util::create_context_callback<el, &el::handle_releasing_lock>(this),
     util::create_context_callback<el, &el::handle_release_lock>(this));
 
@@ -504,6 +506,7 @@ void ExclusiveLock<I>::handle_release_lock(int r) {
       lock_request_needed = m_image_ctx.aio_work_queue->is_lock_request_needed();
       m_lock.Lock();
 
+      m_cookie = "";
       m_watch_handle = 0;
     }
     complete_active_action(r < 0 ? STATE_LOCKED : STATE_UNLOCKED, r);
@@ -540,7 +543,7 @@ void ExclusiveLock<I>::send_shutdown_release() {
   std::string cookie;
   {
     Mutex::Locker locker(m_lock);
-    cookie = encode_lock_cookie();
+    cookie = m_cookie;
   }
 
   using el = ExclusiveLock<I>;
diff --git a/src/librbd/ExclusiveLock.h b/src/librbd/ExclusiveLock.h
index 7e66037..61fa019 100644
--- a/src/librbd/ExclusiveLock.h
+++ b/src/librbd/ExclusiveLock.h
@@ -130,6 +130,7 @@ private:
 
   mutable Mutex m_lock;
   State m_state;
+  std::string m_cookie;
   uint64_t m_watch_handle;
 
   ActionsContexts m_actions_contexts;
diff --git a/src/test/librbd/exclusive_lock/test_mock_ReacquireRequest.cc b/src/test/librbd/exclusive_lock/test_mock_ReacquireRequest.cc
index cd0da24..1ca9f78 100644
--- a/src/test/librbd/exclusive_lock/test_mock_ReacquireRequest.cc
+++ b/src/test/librbd/exclusive_lock/test_mock_ReacquireRequest.cc
@@ -15,20 +15,9 @@
 #include <arpa/inet.h>
 #include <list>
 
-namespace librbd {
-namespace {
-
-struct MockTestImageCtx : public librbd::MockImageCtx {
-  MockTestImageCtx(librbd::ImageCtx &image_ctx)
-    : librbd::MockImageCtx(image_ctx) {
-  }
-};
-
-} // anonymous namespace
-} // namespace librbd
-
 // template definitions
 #include "librbd/exclusive_lock/ReacquireRequest.cc"
+template class librbd::exclusive_lock::ReacquireRequest<librbd::MockImageCtx>;
 
 namespace librbd {
 namespace exclusive_lock {
@@ -40,10 +29,10 @@ using ::testing::StrEq;
 
 class TestMockExclusiveLockReacquireRequest : public TestMockFixture {
 public:
-  typedef ReacquireRequest<MockTestImageCtx> MockReacquireRequest;
-  typedef ExclusiveLock<MockTestImageCtx> MockExclusiveLock;
+  typedef ReacquireRequest<MockImageCtx> MockReacquireRequest;
+  typedef ExclusiveLock<MockImageCtx> MockExclusiveLock;
 
-  void expect_set_cookie(MockTestImageCtx &mock_image_ctx, int r) {
+  void expect_set_cookie(MockImageCtx &mock_image_ctx, int r) {
     EXPECT_CALL(get_mock_io_ctx(mock_image_ctx.md_ctx),
                 exec(mock_image_ctx.header_oid, _, StrEq("lock"),
                      StrEq("set_cookie"), _, _, _))
@@ -57,7 +46,7 @@ TEST_F(TestMockExclusiveLockReacquireRequest, Success) {
   librbd::ImageCtx *ictx;
   ASSERT_EQ(0, open_image(m_image_name, &ictx));
 
-  MockTestImageCtx mock_image_ctx(*ictx);
+  MockImageCtx mock_image_ctx(*ictx);
 
   InSequence seq;
   expect_set_cookie(mock_image_ctx, 0);
@@ -76,7 +65,7 @@ TEST_F(TestMockExclusiveLockReacquireRequest, NotSupported) {
   librbd::ImageCtx *ictx;
   ASSERT_EQ(0, open_image(m_image_name, &ictx));
 
-  MockTestImageCtx mock_image_ctx(*ictx);
+  MockImageCtx mock_image_ctx(*ictx);
 
   InSequence seq;
   expect_set_cookie(mock_image_ctx, -EOPNOTSUPP);
@@ -95,7 +84,7 @@ TEST_F(TestMockExclusiveLockReacquireRequest, Error) {
   librbd::ImageCtx *ictx;
   ASSERT_EQ(0, open_image(m_image_name, &ictx));
 
-  MockTestImageCtx mock_image_ctx(*ictx);
+  MockImageCtx mock_image_ctx(*ictx);
 
   InSequence seq;
   expect_set_cookie(mock_image_ctx, -EBUSY);
