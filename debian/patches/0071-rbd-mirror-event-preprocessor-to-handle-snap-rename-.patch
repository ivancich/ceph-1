From: Jason Dillaman <dillaman@redhat.com>
Date: Fri, 8 Jul 2016 16:19:52 -0400
Subject: rbd-mirror: event preprocessor to handle snap rename operations

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit bad489e6c349149b2c3468ae273d7261797ee17c)

Resolves: rhbz#1353511

For RH downstream: had to drop the following files that are absent from
the 10.2.2 tarball:
     src/CMakeLists.txt
     src/test/rbd_mirror/CMakeLists.txt
---
 src/test/Makefile-client.am                        |   1 +
 .../image_replayer/test_mock_EventPreprocessor.cc  | 265 +++++++++++++++++++++
 src/tools/Makefile-client.am                       |   2 +
 .../rbd_mirror/image_replayer/EventPreprocessor.cc | 202 ++++++++++++++++
 .../rbd_mirror/image_replayer/EventPreprocessor.h  | 118 +++++++++
 5 files changed, 588 insertions(+)
 create mode 100644 src/test/rbd_mirror/image_replayer/test_mock_EventPreprocessor.cc
 create mode 100644 src/tools/rbd_mirror/image_replayer/EventPreprocessor.cc
 create mode 100644 src/tools/rbd_mirror/image_replayer/EventPreprocessor.h

diff --git a/src/test/Makefile-client.am b/src/test/Makefile-client.am
index 006a565..3dd503b 100644
--- a/src/test/Makefile-client.am
+++ b/src/test/Makefile-client.am
@@ -478,6 +478,7 @@ unittest_rbd_mirror_SOURCES = \
 	test/rbd_mirror/test_mock_ImageSync.cc \
 	test/rbd_mirror/image_replayer/test_mock_BootstrapRequest.cc \
 	test/rbd_mirror/image_replayer/test_mock_CreateImageRequest.cc \
+	test/rbd_mirror/image_replayer/test_mock_EventPreprocessor.cc \
 	test/rbd_mirror/image_sync/test_mock_ImageCopyRequest.cc \
 	test/rbd_mirror/image_sync/test_mock_ObjectCopyRequest.cc \
 	test/rbd_mirror/image_sync/test_mock_SnapshotCopyRequest.cc \
diff --git a/src/test/rbd_mirror/image_replayer/test_mock_EventPreprocessor.cc b/src/test/rbd_mirror/image_replayer/test_mock_EventPreprocessor.cc
new file mode 100644
index 0000000..ca1be6f
--- /dev/null
+++ b/src/test/rbd_mirror/image_replayer/test_mock_EventPreprocessor.cc
@@ -0,0 +1,265 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#include "test/rbd_mirror/test_mock_fixture.h"
+#include "librbd/journal/Types.h"
+#include "librbd/journal/TypeTraits.h"
+#include "tools/rbd_mirror/image_replayer/EventPreprocessor.h"
+#include "tools/rbd_mirror/Threads.h"
+#include "test/journal/mock/MockJournaler.h"
+#include "test/librbd/mock/MockImageCtx.h"
+
+namespace librbd {
+
+namespace {
+
+struct MockTestImageCtx : public librbd::MockImageCtx {
+  MockTestImageCtx(librbd::ImageCtx &image_ctx)
+    : librbd::MockImageCtx(image_ctx) {
+  }
+};
+
+} // anonymous namespace
+
+namespace journal {
+
+template <>
+struct TypeTraits<librbd::MockTestImageCtx> {
+  typedef ::journal::MockJournaler Journaler;
+};
+
+} // namespace journal
+} // namespace librbd
+
+// template definitions
+#include "tools/rbd_mirror/image_replayer/EventPreprocessor.cc"
+template class rbd::mirror::image_replayer::EventPreprocessor<librbd::MockTestImageCtx>;
+
+namespace rbd {
+namespace mirror {
+namespace image_replayer {
+
+using testing::_;
+using testing::WithArg;
+
+class TestMockImageReplayerEventPreprocessor : public TestMockFixture {
+public:
+  typedef EventPreprocessor<librbd::MockTestImageCtx> MockEventPreprocessor;
+
+  virtual void SetUp() {
+    TestMockFixture::SetUp();
+
+    librbd::RBD rbd;
+    ASSERT_EQ(0, create_image(rbd, m_local_io_ctx, m_image_name, m_image_size));
+    ASSERT_EQ(0, open_image(m_local_io_ctx, m_image_name, &m_local_image_ctx));
+  }
+
+  void expect_image_refresh(librbd::MockTestImageCtx &mock_remote_image_ctx, int r) {
+    EXPECT_CALL(*mock_remote_image_ctx.state, refresh(_))
+      .WillOnce(CompleteContext(r));
+  }
+
+  void expect_update_client(journal::MockJournaler &mock_journaler, int r) {
+    EXPECT_CALL(mock_journaler, update_client(_, _))
+      .WillOnce(WithArg<1>(CompleteContext(r)));
+  }
+
+  librbd::ImageCtx *m_local_image_ctx;
+  librbd::journal::MirrorPeerClientMeta m_client_meta;
+
+};
+
+TEST_F(TestMockImageReplayerEventPreprocessor, IsNotRequired) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{librbd::journal::RenameEvent{}};
+  ASSERT_FALSE(event_preprocessor.is_required(event_entry));
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, IsRequiredSnapMapPrune) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  m_client_meta.snap_seqs = {{1, 2}, {3, 4}};
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{librbd::journal::RenameEvent{}};
+  ASSERT_TRUE(event_preprocessor.is_required(event_entry));
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, IsRequiredSnapRename) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{librbd::journal::SnapRenameEvent{}};
+  ASSERT_TRUE(event_preprocessor.is_required(event_entry));
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessSnapMapPrune) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, 0);
+  expect_update_client(mock_remote_journaler, 0);
+
+  mock_local_image_ctx.snap_info = {
+    {6, librbd::SnapInfo{"snap", 0U, {}, 0U, 0U}}};
+  m_client_meta.snap_seqs = {{1, 2}, {3, 4}, {5, 6}};
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{librbd::journal::RenameEvent{}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(0, ctx.wait());
+
+  librbd::journal::MirrorPeerClientMeta::SnapSeqs expected_snap_seqs = {{5, 6}};
+  ASSERT_EQ(expected_snap_seqs, m_client_meta.snap_seqs);
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessSnapRename) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, 0);
+  expect_update_client(mock_remote_journaler, 0);
+
+  mock_local_image_ctx.snap_ids = {{"snap", 6}};
+  mock_local_image_ctx.snap_info = {
+    {6, librbd::SnapInfo{"snap", 0U, {}, 0U, 0U}}};
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{
+    librbd::journal::SnapRenameEvent{0, 5, "snap", "new_snap"}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(0, ctx.wait());
+
+  librbd::journal::MirrorPeerClientMeta::SnapSeqs expected_snap_seqs = {{5, 6}};
+  ASSERT_EQ(expected_snap_seqs, m_client_meta.snap_seqs);
+
+  librbd::journal::SnapRenameEvent *event =
+    boost::get<librbd::journal::SnapRenameEvent>(&event_entry.event);
+  ASSERT_EQ(6U, event->snap_id);
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessSnapRenameMissing) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, 0);
+
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{
+    librbd::journal::SnapRenameEvent{0, 5, "snap", "new_snap"}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(-ENOENT, ctx.wait());
+
+  librbd::journal::SnapRenameEvent *event =
+    boost::get<librbd::journal::SnapRenameEvent>(&event_entry.event);
+  ASSERT_EQ(CEPH_NOSNAP, event->snap_id);
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessSnapRenameKnown) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, 0);
+
+  mock_local_image_ctx.snap_info = {
+    {6, librbd::SnapInfo{"snap", 0U, {}, 0U, 0U}}};
+  m_client_meta.snap_seqs = {{5, 6}};
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{
+    librbd::journal::SnapRenameEvent{0, 5, "snap", "new_snap"}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(0, ctx.wait());
+
+  librbd::journal::MirrorPeerClientMeta::SnapSeqs expected_snap_seqs = {{5, 6}};
+  ASSERT_EQ(expected_snap_seqs, m_client_meta.snap_seqs);
+
+  librbd::journal::SnapRenameEvent *event =
+    boost::get<librbd::journal::SnapRenameEvent>(&event_entry.event);
+  ASSERT_EQ(6U, event->snap_id);
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessRefreshError) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, -EINVAL);
+
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{librbd::journal::RenameEvent{}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(-EINVAL, ctx.wait());
+}
+
+TEST_F(TestMockImageReplayerEventPreprocessor, PreprocessClientUpdateError) {
+  librbd::MockTestImageCtx mock_local_image_ctx(*m_local_image_ctx);
+  ::journal::MockJournaler mock_remote_journaler;
+
+  expect_image_refresh(mock_local_image_ctx, 0);
+  expect_update_client(mock_remote_journaler, -EINVAL);
+
+  mock_local_image_ctx.snap_ids = {{"snap", 6}};
+  mock_local_image_ctx.snap_info = {
+    {6, librbd::SnapInfo{"snap", 0U, {}, 0U, 0U}}};
+  MockEventPreprocessor event_preprocessor(mock_local_image_ctx,
+                                           mock_remote_journaler,
+                                           "local mirror uuid",
+                                           &m_client_meta,
+                                           m_threads->work_queue);
+
+  librbd::journal::EventEntry event_entry{
+    librbd::journal::SnapRenameEvent{0, 5, "snap", "new_snap"}};
+  C_SaferCond ctx;
+  event_preprocessor.preprocess(&event_entry, &ctx);
+  ASSERT_EQ(-EINVAL, ctx.wait());
+}
+
+} // namespace image_replayer
+} // namespace mirror
+} // namespace rbd
diff --git a/src/tools/Makefile-client.am b/src/tools/Makefile-client.am
index f396f9f..ec20130 100644
--- a/src/tools/Makefile-client.am
+++ b/src/tools/Makefile-client.am
@@ -101,6 +101,7 @@ librbd_mirror_internal_la_SOURCES = \
 	tools/rbd_mirror/image_replayer/BootstrapRequest.cc \
 	tools/rbd_mirror/image_replayer/CloseImageRequest.cc \
 	tools/rbd_mirror/image_replayer/CreateImageRequest.cc \
+	tools/rbd_mirror/image_replayer/EventPreprocessor.cc \
 	tools/rbd_mirror/image_replayer/OpenImageRequest.cc \
 	tools/rbd_mirror/image_replayer/OpenLocalImageRequest.cc \
 	tools/rbd_mirror/image_replayer/ReplayStatusFormatter.cc \
@@ -126,6 +127,7 @@ noinst_HEADERS += \
 	tools/rbd_mirror/image_replayer/BootstrapRequest.h \
 	tools/rbd_mirror/image_replayer/CloseImageRequest.h \
 	tools/rbd_mirror/image_replayer/CreateImageRequest.h \
+	tools/rbd_mirror/image_replayer/EventPreprocessor.h \
 	tools/rbd_mirror/image_replayer/OpenImageRequest.h \
 	tools/rbd_mirror/image_replayer/OpenLocalImageRequest.h \
 	tools/rbd_mirror/image_replayer/ReplayStatusFormatter.h \
diff --git a/src/tools/rbd_mirror/image_replayer/EventPreprocessor.cc b/src/tools/rbd_mirror/image_replayer/EventPreprocessor.cc
new file mode 100644
index 0000000..2d16402
--- /dev/null
+++ b/src/tools/rbd_mirror/image_replayer/EventPreprocessor.cc
@@ -0,0 +1,202 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#include "EventPreprocessor.h"
+#include "common/debug.h"
+#include "common/dout.h"
+#include "common/errno.h"
+#include "common/WorkQueue.h"
+#include "journal/Journaler.h"
+#include "librbd/ImageCtx.h"
+#include "librbd/ImageState.h"
+#include "librbd/Utils.h"
+#include "librbd/journal/Types.h"
+#include <boost/variant.hpp>
+
+#define dout_subsys ceph_subsys_rbd_mirror
+
+#undef dout_prefix
+#define dout_prefix *_dout << "rbd::mirror::image_replayer::EventPreprocessor: " \
+                           << this << " " << __func__
+
+namespace rbd {
+namespace mirror {
+namespace image_replayer {
+
+using librbd::util::create_context_callback;
+
+template <typename I>
+EventPreprocessor<I>::EventPreprocessor(I &local_image_ctx,
+                                        Journaler &remote_journaler,
+                                        const std::string &local_mirror_uuid,
+                                        MirrorPeerClientMeta *client_meta,
+                                        ContextWQ *work_queue)
+  : m_local_image_ctx(local_image_ctx), m_remote_journaler(remote_journaler),
+    m_local_mirror_uuid(local_mirror_uuid), m_client_meta(client_meta),
+    m_work_queue(work_queue) {
+}
+
+template <typename I>
+EventPreprocessor<I>::~EventPreprocessor() {
+  assert(!m_in_progress);
+}
+
+template <typename I>
+bool EventPreprocessor<I>::is_required(const EventEntry &event_entry) {
+  SnapSeqs snap_seqs(m_client_meta->snap_seqs);
+  return (prune_snap_map(&snap_seqs) ||
+          event_entry.get_event_type() ==
+            librbd::journal::EVENT_TYPE_SNAP_RENAME);
+}
+
+template <typename I>
+void EventPreprocessor<I>::preprocess(EventEntry *event_entry,
+                                      Context *on_finish) {
+  assert(!m_in_progress);
+  m_in_progress = true;
+  m_event_entry = event_entry;
+  m_on_finish = on_finish;
+
+  refresh_image();
+}
+
+template <typename I>
+void EventPreprocessor<I>::refresh_image() {
+  dout(20) << dendl;
+
+  Context *ctx = create_context_callback<
+    EventPreprocessor<I>, &EventPreprocessor<I>::handle_refresh_image>(this);
+  m_local_image_ctx.state->refresh(ctx);
+}
+
+template <typename I>
+void EventPreprocessor<I>::handle_refresh_image(int r) {
+  dout(20) << ": r=" << dendl;
+
+  if (r < 0) {
+    derr << "error encountered during image refresh: " << cpp_strerror(r)
+         << dendl;
+    finish(r);
+    return;
+  }
+
+  preprocess_event();
+}
+
+template <typename I>
+void EventPreprocessor<I>::preprocess_event() {
+  dout(20) << dendl;
+
+  m_snap_seqs = m_client_meta->snap_seqs;
+  m_snap_seqs_updated = prune_snap_map(&m_snap_seqs);
+
+  int r = boost::apply_visitor(PreprocessEventVisitor(this),
+                               m_event_entry->event);
+  if (r < 0) {
+    finish(r);
+    return;
+  }
+
+  update_client();
+}
+
+template <typename I>
+int EventPreprocessor<I>::preprocess_snap_rename(
+    librbd::journal::SnapRenameEvent &event) {
+  dout(20) << ": "
+           << "remote_snap_id=" << event.snap_id << ", "
+           << "src_snap_name=" << event.src_snap_name << ", "
+           << "dest_snap_name=" << event.snap_name << dendl;
+
+  auto snap_seq_it = m_snap_seqs.find(event.snap_id);
+  if (snap_seq_it != m_snap_seqs.end()) {
+    dout(20) << ": remapping remote snap id " << snap_seq_it->first << " "
+             << "to local snap id " << snap_seq_it->second << dendl;
+    event.snap_id = snap_seq_it->second;
+    return 0;
+  }
+
+  auto snap_id_it = m_local_image_ctx.snap_ids.find(event.src_snap_name);
+  if (snap_id_it == m_local_image_ctx.snap_ids.end()) {
+    dout(20) << ": cannot map remote snapshot '" << event.src_snap_name << "' "
+             << "to local snapshot" << dendl;
+    event.snap_id = CEPH_NOSNAP;
+    return -ENOENT;
+  }
+
+  dout(20) << ": mapping remote snap id " << event.snap_id << " "
+           << "to local snap id " << snap_id_it->second << dendl;
+  m_snap_seqs_updated = true;
+  m_snap_seqs[event.snap_id] = snap_id_it->second;
+  event.snap_id = snap_id_it->second;
+  return 0;
+}
+
+template <typename I>
+void EventPreprocessor<I>::update_client() {
+  if (!m_snap_seqs_updated) {
+    finish(0);
+    return;
+  }
+
+  dout(20) << dendl;
+  librbd::journal::MirrorPeerClientMeta client_meta(*m_client_meta);
+  client_meta.snap_seqs = m_snap_seqs;
+
+  librbd::journal::ClientData client_data(client_meta);
+  bufferlist data_bl;
+  ::encode(client_data, data_bl);
+
+  Context *ctx = create_context_callback<
+    EventPreprocessor<I>, &EventPreprocessor<I>::handle_update_client>(
+      this);
+  m_remote_journaler.update_client(data_bl, ctx);
+}
+
+template <typename I>
+void EventPreprocessor<I>::handle_update_client(int r) {
+  dout(20) << ": r=" << dendl;
+
+  if (r < 0) {
+    derr << "failed to update mirror peer journal client: "
+         << cpp_strerror(r) << dendl;
+    finish(r);
+    return;
+  }
+
+  m_client_meta->snap_seqs = m_snap_seqs;
+  finish(0);
+}
+
+template <typename I>
+bool EventPreprocessor<I>::prune_snap_map(SnapSeqs *snap_seqs) {
+  bool pruned = false;
+
+  RWLock::RLocker snap_locker(m_local_image_ctx.snap_lock);
+  for (auto it = snap_seqs->begin(); it != snap_seqs->end(); ) {
+    auto current_it(it++);
+    if (m_local_image_ctx.snap_info.count(current_it->second) == 0) {
+      snap_seqs->erase(current_it);
+      pruned = true;
+    }
+  }
+  return pruned;
+}
+
+template <typename I>
+void EventPreprocessor<I>::finish(int r) {
+  dout(20) << ": r=" << dendl;
+
+  Context *on_finish = m_on_finish;
+  m_on_finish = nullptr;
+  m_event_entry = nullptr;
+  m_in_progress = false;
+  m_snap_seqs_updated = false;
+  m_work_queue->queue(on_finish, r);
+}
+
+} // namespace image_replayer
+} // namespace mirror
+} // namespace rbd
+
+template class rbd::mirror::image_replayer::EventPreprocessor<librbd::ImageCtx>;
diff --git a/src/tools/rbd_mirror/image_replayer/EventPreprocessor.h b/src/tools/rbd_mirror/image_replayer/EventPreprocessor.h
new file mode 100644
index 0000000..6cdf0f6
--- /dev/null
+++ b/src/tools/rbd_mirror/image_replayer/EventPreprocessor.h
@@ -0,0 +1,118 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#ifndef RBD_MIRROR_IMAGE_REPLAYER_EVENT_PREPROCESSOR_H
+#define RBD_MIRROR_IMAGE_REPLAYER_EVENT_PREPROCESSOR_H
+
+#include "include/int_types.h"
+#include "librbd/journal/Types.h"
+#include "librbd/journal/TypeTraits.h"
+#include <map>
+#include <string>
+#include <boost/variant/static_visitor.hpp>
+
+struct Context;
+struct ContextWQ;
+namespace journal { class Journaler; }
+namespace librbd { class ImageCtx; }
+
+namespace rbd {
+namespace mirror {
+namespace image_replayer {
+
+template <typename ImageCtxT = librbd::ImageCtx>
+class EventPreprocessor {
+public:
+  using Journaler = typename librbd::journal::TypeTraits<ImageCtxT>::Journaler;
+  using EventEntry = librbd::journal::EventEntry;
+  using MirrorPeerClientMeta = librbd::journal::MirrorPeerClientMeta;
+
+  static EventPreprocessor *create(ImageCtxT &local_image_ctx,
+                                   Journaler &remote_journaler,
+                                   const std::string &local_mirror_uuid,
+                                   MirrorPeerClientMeta *client_meta,
+                                   ContextWQ *work_queue) {
+    return new EventPreprocessor(local_image_ctx, remote_journaler,
+                                 local_mirror_uuid, client_meta, work_queue);
+  }
+
+  EventPreprocessor(ImageCtxT &local_image_ctx, Journaler &remote_journaler,
+                    const std::string &local_mirror_uuid,
+                    MirrorPeerClientMeta *client_meta, ContextWQ *work_queue);
+  ~EventPreprocessor();
+
+  bool is_required(const EventEntry &event_entry);
+  void preprocess(EventEntry *event_entry, Context *on_finish);
+
+private:
+  /**
+   * @verbatim
+   *
+   * <start>
+   *    |
+   *    v (skip if not required)
+   * REFRESH_IMAGE
+   *    |
+   *    v (skip if not required)
+   * PREPROCESS_EVENT
+   *    |
+   *    v (skip if not required)
+   * UPDATE_CLIENT
+   *
+   * @endverbatim
+   */
+
+  typedef std::map<uint64_t, uint64_t> SnapSeqs;
+
+  class PreprocessEventVisitor : public boost::static_visitor<int> {
+  public:
+    EventPreprocessor *event_preprocessor;
+
+    PreprocessEventVisitor(EventPreprocessor *event_preprocessor)
+      : event_preprocessor(event_preprocessor) {
+    }
+
+    template <typename T>
+    inline int operator()(T&) const {
+      return 0;
+    }
+    inline int operator()(librbd::journal::SnapRenameEvent &event) const {
+      return event_preprocessor->preprocess_snap_rename(event);
+    }
+  };
+
+  ImageCtxT &m_local_image_ctx;
+  Journaler &m_remote_journaler;
+  std::string m_local_mirror_uuid;
+  MirrorPeerClientMeta *m_client_meta;
+  ContextWQ *m_work_queue;
+
+  bool m_in_progress = false;
+  EventEntry *m_event_entry = nullptr;
+  Context *m_on_finish = nullptr;
+
+  SnapSeqs m_snap_seqs;
+  bool m_snap_seqs_updated = false;
+
+  bool prune_snap_map(SnapSeqs *snap_seqs);
+
+  void refresh_image();
+  void handle_refresh_image(int r);
+
+  void preprocess_event();
+  int preprocess_snap_rename(librbd::journal::SnapRenameEvent &event);
+
+  void update_client();
+  void handle_update_client(int r);
+
+  void finish(int r);
+
+};
+
+} // namespace image_replayer
+} // namespace mirror
+} // namespace rbd
+
+extern template class rbd::mirror::image_replayer::EventPreprocessor<librbd::ImageCtx>;
+
+#endif // RBD_MIRROR_IMAGE_REPLAYER_EVENT_PREPROCESSOR_H
