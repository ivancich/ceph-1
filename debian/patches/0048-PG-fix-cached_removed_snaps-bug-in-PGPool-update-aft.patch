From: Samuel Just <sjust@redhat.com>
Date: Mon, 12 Dec 2016 10:35:38 -0800
Subject: PG: fix cached_removed_snaps bug in PGPool::update after map gap

5798fb3bf6d726d14a9c5cb99dc5902eba5b878a actually made 15943 worse
by always creating an out-of-date cached_removed_snaps value after
a map gap rather than only in the case where the the first map after
the gap did not remove any snapshots.

Introduced: 5798fb3bf6d726d14a9c5cb99dc5902eba5b878a
Fixes: http://tracker.ceph.com/issues/15943
Signed-off-by: Samuel Just <sjust@redhat.com>
(cherry picked from commit 5642e7e1b3bb6ffceddacd2f4030eb13a17fcccc)

Resolves: rhbz#1404419
---
 src/osd/PG.cc | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/osd/PG.cc b/src/osd/PG.cc
index 39b5bf8..7178265 100644
--- a/src/osd/PG.cc
+++ b/src/osd/PG.cc
@@ -158,7 +158,7 @@ void PGPool::update(OSDMapRef map)
   auid = pi->auid;
   name = map->get_pool_name(id);
   bool updated = false;
-  if ((map->get_epoch() == cached_epoch + 1) &&
+  if ((map->get_epoch() != cached_epoch + 1) ||
       (pi->get_snap_epoch() == map->get_epoch())) {
     updated = true;
     pi->build_removed_snaps(newly_removed_snaps);
@@ -176,6 +176,16 @@ void PGPool::update(OSDMapRef map)
     }
     snapc = pi->get_snap_context();
   } else {
+    /* 1) map->get_epoch() == cached_epoch + 1 &&
+     * 2) pi->get_snap_epoch() != map->get_epoch()
+     *
+     * From the if branch, 1 && 2 must be true.  From 2, we know that
+     * this map didn't change the set of removed snaps.  From 1, we
+     * know that our cached_removed_snaps matches the previous map.
+     * Thus, from 1 && 2, cached_removed snaps matches the current
+     * set of removed snaps and all we have to do is clear
+     * newly_removed_snaps.
+     */
     newly_removed_snaps.clear();
   }
   cached_epoch = map->get_epoch();
