From: Matt Benjamin <mbenjamin@redhat.com>
Date: Tue, 12 Jul 2016 17:43:43 -0400
Subject: rgw_file: fix rename cases and unify unlink

Rather ordinary rename cases failed in the unlink step.  Fix this,
unifying the unlink path while at it.

Signed-off-by: Matt Benjamin <mbenjamin@redhat.com>
(cherry picked from commit 05af1fbb870a905ea8903594dfc607d346c9dd31)

Resolves rhbz#1357896
---
 src/rgw/rgw_file.cc | 32 ++++++++++++++++----------------
 src/rgw/rgw_file.h  |  4 +++-
 2 files changed, 19 insertions(+), 17 deletions(-)

diff --git a/src/rgw/rgw_file.cc b/src/rgw/rgw_file.cc
index 1bc6b1f..1e3c32f 100644
--- a/src/rgw/rgw_file.cc
+++ b/src/rgw/rgw_file.cc
@@ -208,13 +208,21 @@ namespace rgw {
     return rc;
   }
 
-  int RGWLibFS::unlink(RGWFileHandle* parent, const char *name)
+  int RGWLibFS::unlink(RGWFileHandle* rgw_fh, const char* name, uint32_t flags)
   {
     int rc = 0;
+    RGWFileHandle* parent = nullptr;
 
-    /* atomicity */
-    LookupFHResult fhr = lookup_fh(parent, name, RGWFileHandle::FLAG_LOCK);
-    RGWFileHandle* rgw_fh = get<0>(fhr);
+    if (unlikely(flags & RGWFileHandle::FLAG_UNLINK_THIS)) {
+      /* LOCKED */
+      parent = rgw_fh->get_parent();
+    } else {
+      /* atomicity */
+      parent = rgw_fh;
+      LookupFHResult fhr = lookup_fh(parent, name, RGWFileHandle::FLAG_LOCK);
+      rgw_fh = get<0>(fhr);
+      /* LOCKED */
+    }
 
     if (parent->is_root()) {
       /* XXXX remove uri and deal with bucket and object names */
@@ -293,13 +301,11 @@ namespace rgw {
       break;
       case 1:
       {
-	RGWDeleteObjRequest req(cct, get_user(), src_fh->bucket_name(),
-				src_name);
-	rc = rgwlib.get_fe()->execute_req(&req);
-	if (! rc) {
-	  rc = req.get_ret();
+	rc = this->unlink(rgw_fh /* LOCKED */, _src_name,
+			  RGWFileHandle::FLAG_UNLINK_THIS);
+	/* !LOCKED, -ref */
+	if (! rc)
 	  goto out;
-	}
       }
       break;
       default:
@@ -307,12 +313,6 @@ namespace rgw {
       } /* switch */
     } /* ix */
   out:
-    if (rgw_fh) {
-      rgw_fh->flags |= RGWFileHandle::FLAG_DELETED;
-      fh_cache.remove(rgw_fh->fh.fh_hk.object, rgw_fh, cohort::lru::FLAG_NONE);
-      rgw_fh->mtx.unlock();
-      unref(rgw_fh);
-    }
     return rc;
   } /* RGWLibFS::rename */
 
diff --git a/src/rgw/rgw_file.h b/src/rgw/rgw_file.h
index 42b6649..ca75785 100644
--- a/src/rgw/rgw_file.h
+++ b/src/rgw/rgw_file.h
@@ -231,6 +231,7 @@ namespace rgw {
     static constexpr uint32_t FLAG_BUCKET = 0x0020;
     static constexpr uint32_t FLAG_LOCK =   0x0040;
     static constexpr uint32_t FLAG_DELETED = 0x0080;
+    static constexpr uint32_t FLAG_UNLINK_THIS = 0x0100;
 
 #define CREATE_FLAGS(x) \
     ((x) & ~(RGWFileHandle::FLAG_CREATE|RGWFileHandle::FLAG_LOCK))
@@ -903,7 +904,8 @@ namespace rgw {
     MkObjResult mkdir2(RGWFileHandle* parent, const char *name, struct stat *st,
 		      uint32_t mask, uint32_t flags);
 
-    int unlink(RGWFileHandle* parent, const char *name);
+    int unlink(RGWFileHandle* rgw_fh, const char *name,
+	       uint32_t flags = FLAG_NONE);
 
     /* find existing RGWFileHandle */
     RGWFileHandle* lookup_handle(struct rgw_fh_hk fh_hk) {
