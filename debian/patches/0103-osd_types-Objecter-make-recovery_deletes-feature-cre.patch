From: Josh Durgin <jdurgin@redhat.com>
Date: Mon, 3 Jul 2017 22:05:03 -0400
Subject: osd_types,
 Objecter: make recovery_deletes feature create a new interval

This is needed to create a single place to regenerate the missing set
- at the start of a new interval where support for recovery deletes
changed.

The missing set is otherwise not cleared, so it would need to be
rebuilt in arbitrary places if e.g. an osd not supporting it went down
and restarted with support, or if we used a feature flag command to
trigger rebuilding the missing set.

Signed-off-by: Josh Durgin <jdurgin@redhat.com>
(cherry picked from commit 712f0da05c0a4739a416e0ac003050305de3a775)

Resolves: rhbz#1452780
---
 src/osd/osd_types.cc | 7 ++++++-
 src/osd/osd_types.h  | 2 ++
 src/osdc/Objecter.cc | 4 ++++
 src/osdc/Objecter.h  | 1 +
 4 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/src/osd/osd_types.cc b/src/osd/osd_types.cc
index fb168b9..8e22872 100644
--- a/src/osd/osd_types.cc
+++ b/src/osd/osd_types.cc
@@ -3057,6 +3057,8 @@ bool pg_interval_t::is_new_interval(
   unsigned new_pg_num,
   bool old_sort_bitwise,
   bool new_sort_bitwise,
+  bool old_recovery_deletes,
+  bool new_recovery_deletes,
   pg_t pgid) {
   return old_acting_primary != new_acting_primary ||
     new_acting != old_acting ||
@@ -3065,7 +3067,8 @@ bool pg_interval_t::is_new_interval(
     old_min_size != new_min_size ||
     old_size != new_size ||
     pgid.is_split(old_pg_num, new_pg_num, 0) ||
-    old_sort_bitwise != new_sort_bitwise;
+    old_sort_bitwise != new_sort_bitwise ||
+    old_recovery_deletes != new_recovery_deletes;
 }
 
 bool pg_interval_t::is_new_interval(
@@ -3097,6 +3100,8 @@ bool pg_interval_t::is_new_interval(
 		    osdmap->get_pg_num(pgid.pool()),
 		    lastmap->test_flag(CEPH_OSDMAP_SORTBITWISE),
 		    osdmap->test_flag(CEPH_OSDMAP_SORTBITWISE),
+		    lastmap->test_flag(CEPH_OSDMAP_RECOVERY_DELETES),
+		    osdmap->test_flag(CEPH_OSDMAP_RECOVERY_DELETES),
 		    pgid);
 }
 
diff --git a/src/osd/osd_types.h b/src/osd/osd_types.h
index 5c5c550..254881b 100644
--- a/src/osd/osd_types.h
+++ b/src/osd/osd_types.h
@@ -2254,6 +2254,8 @@ struct pg_interval_t {
     unsigned new_pg_num,
     bool old_sort_bitwise,
     bool new_sort_bitwise,
+    bool old_recovery_deletes,
+    bool new_recovery_deletes,
     pg_t pgid
     );
 
diff --git a/src/osdc/Objecter.cc b/src/osdc/Objecter.cc
index 45c7e66..762f83e 100644
--- a/src/osdc/Objecter.cc
+++ b/src/osdc/Objecter.cc
@@ -2697,6 +2697,7 @@ int Objecter::_calc_target(op_target_t *t, epoch_t *last_force_resend,
   osdmap->pg_to_up_acting_osds(pgid, &up, &up_primary,
 			       &acting, &acting_primary);
   bool sort_bitwise = osdmap->test_flag(CEPH_OSDMAP_SORTBITWISE);
+  bool recovery_deletes = osdmap->test_flag(CEPH_OSDMAP_RECOVERY_DELETES);
   unsigned prev_seed = ceph_stable_mod(pgid.ps(), t->pg_num, t->pg_num_mask);
   if (any_change && pg_interval_t::is_new_interval(
 	t->acting_primary,
@@ -2715,6 +2716,8 @@ int Objecter::_calc_target(op_target_t *t, epoch_t *last_force_resend,
 	pg_num,
 	t->sort_bitwise,
 	sort_bitwise,
+	t->recovery_deletes,
+	recovery_deletes,
 	pg_t(prev_seed, pgid.pool(), pgid.preferred()))) {
     force_resend = true;
   }
@@ -2742,6 +2745,7 @@ int Objecter::_calc_target(op_target_t *t, epoch_t *last_force_resend,
     t->pg_num = pg_num;
     t->pg_num_mask = pi->get_pg_num_mask();
     t->sort_bitwise = sort_bitwise;
+    t->recovery_deletes = recovery_deletes;
     ldout(cct, 10) << __func__ << " "
 		   << " pgid " << pgid << " acting " << acting << dendl;
     t->used_replica = false;
diff --git a/src/osdc/Objecter.h b/src/osdc/Objecter.h
index 8167306..1469c56 100644
--- a/src/osdc/Objecter.h
+++ b/src/osdc/Objecter.h
@@ -1208,6 +1208,7 @@ public:
     int size; ///< the size of the pool when were were last mapped
     int min_size; ///< the min size of the pool when were were last mapped
     bool sort_bitwise; ///< whether the hobject_t sort order is bitwise
+    bool recovery_deletes = false; ///< whether the deletes are performed during recovery instead of peering
 
     bool used_replica;
     bool paused;
