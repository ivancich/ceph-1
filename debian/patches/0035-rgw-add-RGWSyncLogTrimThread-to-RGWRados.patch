From: Casey Bodley <cbodley@redhat.com>
Date: Mon, 6 Jun 2016 16:47:28 -0400
Subject: rgw: add RGWSyncLogTrimThread to RGWRados

Signed-off-by: Casey Bodley <cbodley@redhat.com>
(cherry picked from commit 3b674bbd865cb640266751480c86925a8c07e099)
Resolves: rhbz#1438895
---
 src/common/config_opts.h |  1 +
 src/rgw/rgw_rados.cc     | 49 ++++++++++++++++++++++++++++++++++++++++++++++--
 src/rgw/rgw_rados.h      |  3 +++
 3 files changed, 51 insertions(+), 2 deletions(-)

diff --git a/src/common/config_opts.h b/src/common/config_opts.h
index 3278bf4..c300fbc 100644
--- a/src/common/config_opts.h
+++ b/src/common/config_opts.h
@@ -1442,6 +1442,7 @@ OPTION(rgw_num_async_rados_threads, OPT_INT, 32) // num of threads to use for as
 OPTION(rgw_md_notify_interval_msec, OPT_INT, 200) // metadata changes notification interval to followers
 OPTION(rgw_run_sync_thread, OPT_BOOL, true) // whether radosgw (not radosgw-admin) spawns the sync thread
 OPTION(rgw_sync_lease_period, OPT_INT, 120) // time in second for lease that rgw takes on a specific log (or log shard)
+OPTION(rgw_sync_log_trim_interval, OPT_INT, 1200) // time in seconds between attempts to trim sync logs
 
 OPTION(rgw_realm_reconfigure_delay, OPT_DOUBLE, 2) // seconds to wait before reloading realm configuration
 OPTION(rgw_period_push_interval, OPT_DOUBLE, 2) // seconds to wait before retrying "period push"
diff --git a/src/rgw/rgw_rados.cc b/src/rgw/rgw_rados.cc
index 2c8f4fc..eeeedbc 100644
--- a/src/rgw/rgw_rados.cc
+++ b/src/rgw/rgw_rados.cc
@@ -41,6 +41,9 @@
 
 #include "rgw_coroutine.h"
 
+#include "rgw_boost_asio_yield.h"
+#undef fork // fails to compile RGWPeriod::fork() below
+
 #include "common/Clock.h"
 
 #include "include/rados/librados.hpp"
@@ -3018,6 +3021,33 @@ public:
   }
 };
 
+class RGWSyncLogTrimThread : public RGWSyncProcessorThread
+{
+  RGWCoroutinesManager crs;
+  RGWRados *store;
+  RGWHTTPManager http;
+  const utime_t trim_interval;
+
+  uint64_t interval_msec() override { return 0; }
+  void stop_process() override { crs.stop(); }
+public:
+  RGWSyncLogTrimThread(RGWRados *store, int interval)
+    : RGWSyncProcessorThread(store), crs(store->ctx(), nullptr), store(store),
+      http(store->ctx(), crs.get_completion_mgr()),
+      trim_interval(interval, 0)
+  {}
+
+  int init() override {
+    return http.set_threaded();
+  }
+  int process() override {
+    crs.run(new RGWDataLogTrimCR(store, &http,
+                                 cct->_conf->rgw_data_log_num_shards,
+                                 trim_interval));
+    return 0;
+  }
+};
+
 void RGWRados::wakeup_meta_sync_shards(set<int>& shard_ids)
 {
   Mutex::Locker l(meta_sync_thread_lock);
@@ -3134,6 +3164,9 @@ void RGWRados::finalize()
       RGWDataSyncProcessorThread *thread = iter.second;
       thread->stop();
     }
+    if (sync_log_trimmer) {
+      sync_log_trimmer->stop();
+    }
   }
   if (async_rados) {
     async_rados->stop();
@@ -3147,6 +3180,8 @@ void RGWRados::finalize()
       delete thread;
     }
     data_sync_processor_threads.clear();
+    delete sync_log_trimmer;
+    sync_log_trimmer = nullptr;
   }
   if (finisher) {
     finisher->stop();
@@ -3905,7 +3940,7 @@ int RGWRados::init_complete()
     meta_sync_processor_thread = new RGWMetaSyncProcessorThread(this, async_rados);
     ret = meta_sync_processor_thread->init();
     if (ret < 0) {
-      ldout(cct, 0) << "ERROR: failed to initialize" << dendl;
+      ldout(cct, 0) << "ERROR: failed to initialize meta sync thread" << dendl;
       return ret;
     }
     meta_sync_processor_thread->start();
@@ -3916,12 +3951,22 @@ int RGWRados::init_complete()
       RGWDataSyncProcessorThread *thread = new RGWDataSyncProcessorThread(this, async_rados, iter->first);
       ret = thread->init();
       if (ret < 0) {
-        ldout(cct, 0) << "ERROR: failed to initialize" << dendl;
+        ldout(cct, 0) << "ERROR: failed to initialize data sync thread" << dendl;
         return ret;
       }
       thread->start();
       data_sync_processor_threads[iter->first] = thread;
     }
+    auto interval = cct->_conf->rgw_sync_log_trim_interval;
+    if (interval > 0) {
+      sync_log_trimmer = new RGWSyncLogTrimThread(this, interval);
+      ret = sync_log_trimmer->init();
+      if (ret < 0) {
+        ldout(cct, 0) << "ERROR: failed to initialize sync log trim thread" << dendl;
+        return ret;
+      }
+      sync_log_trimmer->start();
+    }
   }
   data_notifier = new RGWDataNotifier(this);
   data_notifier->start();
diff --git a/src/rgw/rgw_rados.h b/src/rgw/rgw_rados.h
index ccc9753..59c2411 100644
--- a/src/rgw/rgw_rados.h
+++ b/src/rgw/rgw_rados.h
@@ -32,6 +32,7 @@ class RGWDataNotifier;
 class RGWObjectExpirer;
 class RGWMetaSyncProcessorThread;
 class RGWDataSyncProcessorThread;
+class RGWSyncLogTrimThread;
 class RGWRESTConn;
 
 /* flags for put_obj_meta() */
@@ -1823,6 +1824,8 @@ class RGWRados
   RGWMetaSyncProcessorThread *meta_sync_processor_thread;
   map<string, RGWDataSyncProcessorThread *> data_sync_processor_threads;
 
+  RGWSyncLogTrimThread *sync_log_trimmer{nullptr};
+
   Mutex meta_sync_thread_lock;
   Mutex data_sync_thread_lock;
 
