From: Josh Durgin <jdurgin@redhat.com>
Date: Fri, 21 Jul 2017 19:01:12 -0400
Subject: osd/ReplicatedPG: explicitly remove objects when deleting them

In the EC case, we would rely on log processing of delete log entries
to add a remove operation to the local transaction. Make this explicit
in the transaction to begin with instead, so it works when log
processing does not handle the delete.
Note: this is not a cherry-pick because in master ec-overwrites rewrote
this code so it was not an issue.

Signed-off-by: Josh Durgin <jdurgin@redhat.com>

Resolves: rhbz#1452780
---
 src/osd/ReplicatedPG.cc | 22 ++++++++--------------
 1 file changed, 8 insertions(+), 14 deletions(-)

diff --git a/src/osd/ReplicatedPG.cc b/src/osd/ReplicatedPG.cc
index 301fd1f..6470fe9 100644
--- a/src/osd/ReplicatedPG.cc
+++ b/src/osd/ReplicatedPG.cc
@@ -3506,9 +3506,8 @@ ReplicatedPG::OpContextUPtr ReplicatedPG::trim_object(const hobject_t &coid)
       ctx->log.back().mod_desc.update_snaps(snaps);
       if (ctx->log.back().mod_desc.rmobject(ctx->at_version.version)) {
 	t->stash(coid, ctx->at_version.version);
-      } else {
-	t->remove(coid);
       }
+      t->remove(coid);
     } else {
       t->remove(coid);
       ctx->log.back().mod_desc.mark_unrollbackable();
@@ -3573,9 +3572,8 @@ ReplicatedPG::OpContextUPtr ReplicatedPG::trim_object(const hobject_t &coid)
     if (pool.info.require_rollback()) {
       if (ctx->log.back().mod_desc.rmobject(ctx->at_version.version)) {
 	t->stash(snapoid, ctx->at_version.version);
-      } else {
-	t->remove(snapoid);
       }
+      t->remove(snapoid);
     } else {
       t->remove(snapoid);
       ctx->log.back().mod_desc.mark_unrollbackable();
@@ -6030,9 +6028,9 @@ inline int ReplicatedPG::_delete_oid(OpContext *ctx, bool no_whiteout)
   if (pool.info.require_rollback()) {
     if (ctx->mod_desc.rmobject(ctx->at_version.version)) {
       t->stash(soid, ctx->at_version.version);
-    } else {
-      t->remove(soid);
     }
+    t->remove(soid);
+
     map<string, bufferlist> new_attrs;
     replace_cached_attrs(ctx, ctx->obc, new_attrs);
   } else {
@@ -6182,9 +6180,8 @@ int ReplicatedPG::_rollback_to(OpContext *ctx, ceph_osd_op& op)
 	if (obs.exists) {
 	  if (ctx->mod_desc.rmobject(ctx->at_version.version)) {
 	    t->stash(soid, ctx->at_version.version);
-	  } else {
-	    t->remove(soid);
 	  }
+	  t->remove(soid);
 	}
 	replace_cached_attrs(ctx, ctx->obc, rollback_to->attr_cache);
       } else {
@@ -6653,9 +6650,8 @@ void ReplicatedPG::finish_ctx(OpContext *ctx, int log_op_type, bool maintain_ssc
 	  if (pool.info.require_rollback()) {
 	    if (ctx->log.back().mod_desc.rmobject(ctx->at_version.version)) {
 	      ctx->op_t->stash(snapoid, ctx->at_version.version);
-	    } else {
-	      ctx->op_t->remove(snapoid);
 	    }
+	    ctx->op_t->remove(snapoid);
 	  } else {
 	    ctx->op_t->remove(snapoid);
 	    ctx->log.back().mod_desc.mark_unrollbackable();
@@ -7498,9 +7494,8 @@ void ReplicatedPG::finish_copyfrom(OpContext *ctx)
     if (obs.exists) {
       if (ctx->mod_desc.rmobject(ctx->at_version.version)) {
 	ctx->op_t->stash(obs.oi.soid, ctx->at_version.version);
-      } else {
-	ctx->op_t->remove(obs.oi.soid);
       }
+      ctx->op_t->remove(obs.oi.soid);
     }
     ctx->mod_desc.create();
     replace_cached_attrs(ctx, ctx->obc, cb->results->attrs);
@@ -11868,9 +11863,8 @@ void ReplicatedPG::hit_set_trim(OpContextUPtr &ctx, unsigned max)
       if (ctx->log.back().mod_desc.rmobject(
 	  ctx->at_version.version)) {
 	ctx->op_t->stash(oid, ctx->at_version.version);
-      } else {
-	ctx->op_t->remove(oid);
       }
+      ctx->op_t->remove(oid);
     } else {
       ctx->op_t->remove(oid);
       ctx->log.back().mod_desc.mark_unrollbackable();
