From: Jason Dillaman <dillaman@redhat.com>
Date: Fri, 13 May 2016 16:17:37 -0400
Subject: journal: ignore flush on closed/overflowed object

The journal would be in-progress on transitioning to a new
object recorder in a newer object set.  Once the records
re-attach to the new object player they will automatically
flush.

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit a13cb821f71b6b1b3378464bcc2d8318eb0da48a)
(cherry picked from commit 821d92af2fcc43ff560f01c78ff699ad7df33daa)
---
 src/journal/ObjectRecorder.cc | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/journal/ObjectRecorder.cc b/src/journal/ObjectRecorder.cc
index c7f62b4..f9a4110 100644
--- a/src/journal/ObjectRecorder.cc
+++ b/src/journal/ObjectRecorder.cc
@@ -119,7 +119,10 @@ void ObjectRecorder::flush(const FutureImplPtr &future) {
     return;
   }
 
-  assert(!m_object_closed);
+  if (m_object_closed || m_overflowed) {
+    return;
+  }
+
   AppendBuffers::iterator it;
   for (it = m_append_buffers.begin(); it != m_append_buffers.end(); ++it) {
     if (it->first == future) {
@@ -184,7 +187,11 @@ bool ObjectRecorder::append(const AppendBuffer &append_buffer,
                             bool *schedule_append) {
   assert(m_lock.is_locked());
 
-  bool flush_requested = append_buffer.first->attach(&m_flush_handler);
+  bool flush_requested = false;
+  if (!m_object_closed && !m_overflowed) {
+    flush_requested = append_buffer.first->attach(&m_flush_handler);
+  }
+
   m_append_buffers.push_back(append_buffer);
   m_pending_bytes += append_buffer.second.length();
 
