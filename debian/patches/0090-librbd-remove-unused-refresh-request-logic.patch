From: Jason Dillaman <dillaman@redhat.com>
Date: Wed, 17 Aug 2016 15:16:37 -0400
Subject: librbd: remove unused refresh request logic

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit 5156b438d5ad69803b4d4529083039db825d6c8c)

Resolves: rhbz#1379837
---
 src/librbd/ImageState.cc              | 15 +--------------
 src/librbd/ImageState.h               |  7 +------
 src/test/librbd/mock/MockImageState.h |  1 -
 3 files changed, 2 insertions(+), 21 deletions(-)

diff --git a/src/librbd/ImageState.cc b/src/librbd/ImageState.cc
index 3e0a385..da9f6d9 100644
--- a/src/librbd/ImageState.cc
+++ b/src/librbd/ImageState.cc
@@ -318,18 +318,6 @@ template <typename I>
 void ImageState<I>::refresh(Context *on_finish) {
   CephContext *cct = m_image_ctx->cct;
   ldout(cct, 20) << __func__ << dendl;
-  refresh(false, on_finish);
-}
-
-template <typename I>
-void ImageState<I>::acquire_lock_refresh(Context *on_finish) {
-  CephContext *cct = m_image_ctx->cct;
-  ldout(cct, 20) << __func__ << dendl;
-  refresh(true, on_finish);
-}
-
-template <typename I>
-void ImageState<I>::refresh(bool acquiring_lock, Context *on_finish) {
 
   m_lock.Lock();
   if (is_closed()) {
@@ -340,7 +328,6 @@ void ImageState<I>::refresh(bool acquiring_lock, Context *on_finish) {
 
   Action action(ACTION_TYPE_REFRESH);
   action.refresh_seq = m_refresh_seq;
-  action.refresh_acquiring_lock = acquiring_lock;
   execute_action_unlock(action, on_finish);
 }
 
@@ -633,7 +620,7 @@ void ImageState<I>::send_refresh_unlock() {
     *m_image_ctx, create_context_callback<
       ImageState<I>, &ImageState<I>::handle_refresh>(this));
   image::RefreshRequest<I> *req = image::RefreshRequest<I>::create(
-    *m_image_ctx, action_context.refresh_acquiring_lock, ctx);
+    *m_image_ctx, false, ctx);
 
   m_lock.Unlock();
   req->send();
diff --git a/src/librbd/ImageState.h b/src/librbd/ImageState.h
index 2e0fb63..412730e 100644
--- a/src/librbd/ImageState.h
+++ b/src/librbd/ImageState.h
@@ -38,7 +38,6 @@ public:
   int refresh();
   int refresh_if_required();
   void refresh(Context *on_finish);
-  void acquire_lock_refresh(Context *on_finish);
 
   void snap_set(const std::string &snap_name, Context *on_finish);
 
@@ -73,7 +72,6 @@ private:
   struct Action {
     ActionType action_type;
     uint64_t refresh_seq = 0;
-    bool refresh_acquiring_lock = false;
     std::string snap_name;
     Context *on_ready = nullptr;
 
@@ -85,8 +83,7 @@ private:
       }
       switch (action_type) {
       case ACTION_TYPE_REFRESH:
-        return (refresh_seq == action.refresh_seq &&
-                refresh_acquiring_lock == action.refresh_acquiring_lock);
+        return (refresh_seq == action.refresh_seq);
       case ACTION_TYPE_SET_SNAP:
         return snap_name == action.snap_name;
       case ACTION_TYPE_LOCK:
@@ -115,8 +112,6 @@ private:
   bool is_transition_state() const;
   bool is_closed() const;
 
-  void refresh(bool acquiring_lock, Context *on_finish);
-
   void append_context(const Action &action, Context *context);
   void execute_next_action_unlock();
   void execute_action_unlock(const Action &action, Context *context);
diff --git a/src/test/librbd/mock/MockImageState.h b/src/test/librbd/mock/MockImageState.h
index 603871b..59c9da8 100644
--- a/src/test/librbd/mock/MockImageState.h
+++ b/src/test/librbd/mock/MockImageState.h
@@ -13,7 +13,6 @@ namespace librbd {
 struct MockImageState {
   MOCK_CONST_METHOD0(is_refresh_required, bool());
   MOCK_METHOD1(refresh, void(Context*));
-  MOCK_METHOD1(acquire_lock_refresh, void(Context*));
 
   MOCK_METHOD1(open, void(Context*));
 
