From: Jason Dillaman <dillaman@redhat.com>
Date: Wed, 25 May 2016 14:00:34 -0400
Subject: rbd-mirror: stop stale replayers before starting new replayers

If the connection details are tweaked for a remote peer, stop
the existing replayer before potentially starting a new replayer
against the same remote.

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit 6a2adca2a47b384f64c20996b9fc77010a70bc22)
(cherry picked from commit 0745cc3db35a349799891c8397249bf8d088ef83)

Resolves: rhbz#1340476
---
 src/tools/rbd_mirror/Mirror.cc | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/src/tools/rbd_mirror/Mirror.cc b/src/tools/rbd_mirror/Mirror.cc
index 73e9801..02dda7c 100644
--- a/src/tools/rbd_mirror/Mirror.cc
+++ b/src/tools/rbd_mirror/Mirror.cc
@@ -342,6 +342,19 @@ void Mirror::update_replayers(const map<peer_t, set<int64_t> > &peer_configs)
 {
   dout(20) << "enter" << dendl;
   assert(m_lock.is_locked());
+
+  // remove stale replayers before creating new replayers
+  for (auto it = m_replayers.begin(); it != m_replayers.end();) {
+    peer_t peer = it->first;
+    if (peer_configs.find(peer) == peer_configs.end()) {
+      dout(20) << "removing replayer for " << peer << dendl;
+      // TODO: make async
+      m_replayers.erase(it++);
+    } else {
+      ++it;
+    }
+  }
+
   for (auto &kv : peer_configs) {
     const peer_t &peer = kv.first;
     if (m_replayers.find(peer) == m_replayers.end()) {
@@ -356,17 +369,6 @@ void Mirror::update_replayers(const map<peer_t, set<int64_t> > &peer_configs)
       m_replayers.insert(std::make_pair(peer, std::move(replayer)));
     }
   }
-
-  // TODO: make async
-  for (auto it = m_replayers.begin(); it != m_replayers.end();) {
-    peer_t peer = it->first;
-    if (peer_configs.find(peer) == peer_configs.end()) {
-      dout(20) << "removing replayer for " << peer << dendl;
-      m_replayers.erase(it++);
-    } else {
-      ++it;
-    }
-  }
 }
 
 } // namespace mirror
