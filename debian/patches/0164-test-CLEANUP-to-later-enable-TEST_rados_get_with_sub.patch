From: David Zafman <dzafman@redhat.com>
Date: Fri, 11 Nov 2016 17:04:03 -0800
Subject: test: CLEANUP to later enable
 TEST_rados_get_with_subreadall_eio_shard_*

Signed-off-by: David Zafman <dzafman@redhat.com>
(cherry picked from commit 6a78b81f37fd6fb495672142fe9d135d144391c6)
(cherry picked from commit 14ac81ead965eb0393ac6f397a5a2803ae2afcf0)

Resolves: rhbz#1508935
---
 src/test/erasure-code/test-erasure-eio.sh | 47 +++++++++----------------------
 1 file changed, 14 insertions(+), 33 deletions(-)

diff --git a/src/test/erasure-code/test-erasure-eio.sh b/src/test/erasure-code/test-erasure-eio.sh
index 5690a11..2d51bc5 100755
--- a/src/test/erasure-code/test-erasure-eio.sh
+++ b/src/test/erasure-code/test-erasure-eio.sh
@@ -40,15 +40,8 @@ function run() {
 }
 
 function setup_osds() {
-    local subread=$1
-
     for id in $(seq 0 3) ; do
-        # TODO: the feature of "osd-pool-erasure-code-subread-all" is not yet supported.
-        if [ -n "$osd_pool_erasure_code_subread_all__is_supported" ]; then
-            run_osd $dir $id "--osd-pool-erasure-code-subread-all=$subread" || return 1
-        else
-            run_osd $dir $id || return 1
-        fi
+        run_osd $dir $id || return 1
     done
     wait_for_clean || return 1
 
@@ -116,14 +109,14 @@ function rados_put_get() {
     local dir=$1
     local poolname=$2
     local objname=${3:-SOMETHING}
-    local expect=${4:-0}
-    local recovery=$5
+    local recovery=$4
 
     #
     # get and put an object, compare they are equal
     #
     rados_put $dir $poolname $objname || return 1
-    rados_get $dir $poolname $objname $expect || return 1
+    # We can read even though caller injected read error on one of the shards
+    rados_get $dir $poolname $objname 0 || return 1
 
     if [ -n "$recovery" ];
     then
@@ -136,7 +129,8 @@ function rados_put_get() {
         local last=$((${#initial_osds[@]} - 1))
         ceph osd out ${initial_osds[$last]} || return 1
         ! get_osds $poolname $objname | grep '\<'${initial_osds[$last]}'\>' || return 1
-        rados_get $dir $poolname $objname $expect || return 1
+        # This will fail since one shard is out and one shard has injected read error
+        rados_get $dir $poolname $objname 1 || return 1
         ceph osd in ${initial_osds[$last]} || return 1
     fi
 
@@ -172,10 +166,11 @@ function rados_get_data_eio() {
     local poolname=pool-jerasure
     local objname=obj-eio-$$-$shard_id
     inject_eio $objname $dir $shard_id || return 1
-    rados_put_get $dir $poolname $objname 0 $recovery || return 1
+    rados_put_get $dir $poolname $objname $recovery || return 1
 
     shard_id=$(expr $shard_id + 1)
     inject_eio $objname $dir $shard_id || return 1
+    # Now 2 out of 3 shards get EIO, so should fail
     rados_get $dir $poolname $objname 1 || return 1
 }
 
@@ -243,7 +238,7 @@ function rados_get_data_bad_size() {
 #
 function TEST_rados_get_subread_eio_shard_0() {
     local dir=$1
-    setup_osds false || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -255,7 +250,7 @@ function TEST_rados_get_subread_eio_shard_0() {
 
 function TEST_rados_get_subread_eio_shard_1() {
     local dir=$1
-    setup_osds false || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -274,7 +269,7 @@ function TEST_rados_get_subread_eio_shard_1() {
 #
 function TEST_rados_get_bad_size_shard_0() {
     local dir=$1
-    setup_osds false || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -288,7 +283,7 @@ function TEST_rados_get_bad_size_shard_0() {
 
 function TEST_rados_get_bad_size_shard_1() {
     local dir=$1
-    setup_osds false || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -301,19 +296,11 @@ function TEST_rados_get_bad_size_shard_1() {
 }
 
 : <<'DISABLED_TESTS'
-# this test case is aimed to test the fix of https://github.com/ceph/ceph/pull/2952
-# this test case can test both client read and recovery read on EIO
-# but at this moment, above pull request ONLY resolves client read on EIO
-# so this case will fail at function *rados_put_get* when one OSD out
-# so disable this case for now until both crashes of client read and recovery read
-# on EIO to be fixed
-#
-
 function TEST_rados_get_with_subreadall_eio_shard_0() {
     local dir=$1
     local shard_id=0
 
-    setup_osds true || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -321,7 +308,6 @@ function TEST_rados_get_with_subreadall_eio_shard_0() {
     local shard_id=0
     rados_get_data_eio $dir $shard_id recovery || return 1
 
-    check_pg_status $pg "inconsistent" || return 1
     delete_pool $poolname
 }
 
@@ -329,7 +315,7 @@ function TEST_rados_get_with_subreadall_eio_shard_1() {
     local dir=$1
     local shard_id=0
 
-    setup_osds true || return 1
+    setup_osds || return 1
 
     local poolname=pool-jerasure
     create_erasure_coded_pool $poolname || return 1
@@ -337,11 +323,6 @@ function TEST_rados_get_with_subreadall_eio_shard_1() {
     local shard_id=1
     rados_get_data_eio $dir $shard_id recovery || return 1
 
-    # the reason to skip this check when current shardid != 0 is that the first
-    # k chunks returned is not always containing current shardid, so this pg may
-    # not be marked as inconsistent. However, primary OSD (when shard_id == 0) is
-    # always the faster one normally, so we can check pg status.
-    ## check_pg_status $pg "inconsistent" || return 1
     delete_pool $poolname
 }
 DISABLED_TESTS
