From: Jason Dillaman <dillaman@redhat.com>
Date: Thu, 23 Jun 2016 09:03:24 -0400
Subject: librbd: memory leak possible if journal op event failed

Signed-off-by: Jason Dillaman <dillaman@redhat.com>

Resolves: rhbz#1349402
---
 src/librbd/journal/Replay.cc | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/src/librbd/journal/Replay.cc b/src/librbd/journal/Replay.cc
index f1da098..dfbc546 100644
--- a/src/librbd/journal/Replay.cc
+++ b/src/librbd/journal/Replay.cc
@@ -108,24 +108,29 @@ struct C_RefreshIfRequired : public Context {
   C_RefreshIfRequired(I &image_ctx, Context *on_finish)
     : image_ctx(image_ctx), on_finish(on_finish) {
   }
+  virtual ~C_RefreshIfRequired() {
+    delete on_finish;
+  }
 
   virtual void finish(int r) override {
     CephContext *cct = image_ctx.cct;
+    Context *ctx = on_finish;
+    on_finish = nullptr;
 
     if (r < 0) {
       lderr(cct) << "C_RefreshIfRequired: " << __func__ << ": r=" << r << dendl;
-      image_ctx.op_work_queue->queue(on_finish, r);
+      image_ctx.op_work_queue->queue(ctx, r);
       return;
     }
 
     if (image_ctx.state->is_refresh_required()) {
       ldout(cct, 20) << "C_RefreshIfRequired: " << __func__ << ": "
                      << "refresh required" << dendl;
-      image_ctx.state->refresh(on_finish);
+      image_ctx.state->refresh(ctx);
       return;
     }
 
-    image_ctx.op_work_queue->queue(on_finish, 0);
+    image_ctx.op_work_queue->queue(ctx, 0);
   }
 };
 
